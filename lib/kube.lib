
init_bash_module_kube() {
    use_module render
    declare -g kube_cluster
    declare -Ag kubeconfig
    declare -Ag kubecontext
    declare -Ag kube_resource_alias
    declare -g kube_resource_list=""
    declare -gA kube_default_replicas
    add_action kube-get "get current manifests from cluster to --to <path> (default) deployed/manifests"
    add_action kube-apply "apply rendered manifests with cluster (kubectl apply)"
    add_action kube-diff "compare rendered manifests with cluster (kubectl diff)"
    add_action kube-tmp-scale "scale resource(s) without changing source or deployment files"
    add_action kube-restart "restart resource(s)"
    unset_vars+=" kube_cluster namespace"
}


kubectl_options() {
    local cl=${kube_cluster}
    local cfg=${kubeconfig[$cl]:-default}
    local opt=""
    if [[ $cfg != default ]]; then
        opt="--kubeconfig $cfg " # extra space at end
    fi
    opt+="--context ${kubecontext[$cl]}"
    echo $opt
}

filter-kube-diff-output() { grep -E '^[+-] |^---'; }
run_action_kube-diff() {
    run_action_render
    info kube-diff ${env} ${appname} to ${output_dir}
    if $(log_is_verbose); then
        verbose_cmd kubectl diff $(kubectl_options) -f $output_dir || true
    else
        verbose_pipe filter-kube-diff-output kubectl diff $(kubectl_options) -f $output_dir || true
    fi
}

run_action_kube-apply() {
    run_action_kube-dirun_action_kube-get() {
    verbose_cmd kubectl $(kubectl_options) -n $namespace get ${extra_args:-pods,deploy,sts,cm}
}
ff
    info kube apply $output_dir
    verbose_cmd kubectl apply $(kubectl_options) -f $output_dir
}

split_kubectl_output_into_files() {
    yq  '.items.[]' -s \"$output_dir/\"'+ (.kind | downcase) + "_" + .metadata.name + ".yaml"'
}

run_action_kube-get-manifests() {
    info kube get manifests  ${env} ${appname} to ${output_dir}
    verbose_cmd rm -rf ${output_dir}
    verbose_cmd mkdir -p ${output_dir}
    verbose_pipe split_kubectl_output_into_files kubectl ${kubectl_options[$env]} -n "${namespace}" get deploy,svc,sts,cm,ingress -o yaml
    ignore_files=configmap_kube-root-ca.crt.yaml
    ignore_files+=" deployment_ingress-nginx-controller.yaml"
    ignore_files+=" service_ingress-nginx-controller-admission.yaml"
    ignore_files+=" service_ingress-nginx-controller.yaml"
    for f in ${ignore_files}; do
        rm -f "${output_dir}/$f"
    done
    for f in "${output_dir}"/*.yaml; do
         yq -i 'del(.metadata.annotations.["kubectl.kubernetes.io/last-applied-configuration"])' "${f}"
         yq -i 'del(.metadata.uid)' "${f}"
         yq -i 'del(.metadata.resourceVersion)' "${f}"
         yq -i 'del(.metadata.creationTimestamp)' "${f}"
    done
}

run_action_kube-get() {
    verbose_cmd kubectl $(kubectl_options) -n $namespace get ${extra_args:-pods,deploy,sts,cm}
}
run_action_kube-watch() {
    verbose_cmd watch kubectl $(kubectl_options) -n $namespace get ${extra_args:-pods,deploy,sts,cm}
}
run_action_kube-restart() {
    local res
    for res in ${kube_resource_list//,/ }; do
        res=${kube_resource_alias[$res]:-$res}
        verbose_cmd kubectl $(kubectl_options) -n $namespace rollout restart $res
    done
}
run_action_kube-tmp-scale() {
    local res
    for res in ${kube_resource_list//,/ }; do
        local repl=${kube_replicas:-default}
        if [[  $repl == default ]]; then
            repl=${kube_default_replicas[$res]}
        fi
        res=${kube_resource_alias[$res]:-$res}
        verbose_cmd kubectl $(kubectl_options) -n $namespace scale $res --replicas $repl
    done
}
