
init_argparse() {
    declare -gA aliases=()
    declare -ga parsed_args=()

    declare -g karmah_paths=""
    declare -g subdirs=""
    declare -ga updates=()
    declare -gA command_help=()
    declare -gA action_help=()
    declare -g action_list=""
    declare -g command
}

add_command() {
    command_help["$1"]="${2:-no help specfied}"
}
add_action() {
    action_help["$1"]="${2:-no help specfied}"
}



replace_aliases() {
    for arg in "${@}"; do
        local al="${aliases[$arg]:-none}"
        if [[ "$al" != none ]]; then
            replaced=true
            parsed_args+=($al)
        else
            parsed_args+=("$arg")
        fi
    done
}

parse_options() {
    local replaced=false
    local collect_unknown_args=false
    declare -g extra_args=""
    replace_aliases "${@}"
    set -- "${parsed_args[@]}"
    log_level=$log_level_info
    while [[ $# > 0 ]]; do
        arg=$1
        case $arg in
            -h|--help|help) show_help; exit 0;;
            --debug)        set -x;;
            -s|--subdir)    subdirs+=" $2";      shift;;
            -t|--to)        to_dir="$2";         shift;;
            -w|--with)      with_dir="$2";       shift;;
            -a|--action)    action_list+=" $2";  shift;;
            -m|--message)   git_commit_message="$2"; shift;;
            -r|--resource)  kube_resource_list+=" $2"; shift;;
            -R|--replicas)  kube_replicas="$2";  shift;;
            -V|--version)   update_version="$2"; shift;;
            kube-get)       action_list+="kube-get"; collect_unknown_args=true ;;
            kube-watch)     action_list+="kube-watch"; collect_unknown_args=true ;;
            *)
                parse_result=0
                parse_args_logging "$@"
                if [[ "$parse_result" > 0 ]]; then
                    shift $(( "$parse_result" - 1))
                else
                    if [[ "${command_help["$arg"]:-none}" != none  ]]; then
                        command="run_command_$arg"
                    elif [[ "${action_help["$arg"]:-none}" != none  ]]; then
                        action_list+="$arg"
                    elif [[ -f ${arg} ]]; then karmah_paths+=" ${arg}"
                    elif [[ -d ${arg} ]]; then karmah_paths+=" ${arg%%/}" # remove a trailing /
                    elif $collect_unknown_args; then extra_args+=" $arg"
                    else
                        echo unknown argument ${arg}, should be a command, file or directory
                        show_help
                        exit 1
                    fi
                fi
        esac
        shift
    done
    verbose COMMAND $(basename $0) ${parsed_args[@]}
}
