
init_argparse() {
    declare -gA aliases=()
    declare -ga parsed_args=()

    declare -g karmah_paths=""
    declare -g subdirs=""
    declare -ga updates=()
    declare -gA command_help=()
    declare -ga option_help=()
    declare -gA option_func=()
    declare -gA short_option_func=()

    declare -gA action_help=()
    declare -g action_list=""
    declare -g command
}

init_bash_module_argparse() {
    use_module logging
    add_option s subdir   dir   "add subdir to list of subdirs (can be comma separated list)"
    add_option t to       path  "other path to render to (default is tmp/manifests)"
    add_option w with     path  used for comparison between two manifest trees
    add_option u update   expr  update source files before rendering
    add_option a action   act   add action to list of actions to perform
    add_option m message  msg   set message to us with git commit
}

add_option() {
    local short=$1
    local name=$2
    local arg=$3
    shift 3
    local help=$@
    option_func[--$name]=parse_option_$name
    if [[ -z $short ]]; then
        name="--$name"
    else
        option_func[-$short]=parse_option_$name
        name="-$short|--$name"
    fi
    [[ -z $arg ]] || name+=" <$arg>"
    option_help+=("$(printf "  %-20s %s\n" "$name" "$help")")
}

add_command() {
    command_help["$1"]="${2:-no help specfied}"
}
add_action() {
    action_help["$1"]="${2:-no help specfied}"
}

parse_option() {
    local name=$1
    local func=${option_func[$name]:-}
    if [[ -z $func ]]; then
        error "unknown option $name"
        show_short_help
        exit 1
    fi
    shift
    extra_shift=0
    "${option_func[$name]}" "$@"
}


replace_aliases() {
    for arg in "${@}"; do
        local al="${aliases[$arg]:-none}"
        if [[ "$al" != none ]]; then
            replaced=true
            parsed_args+=($al)
        else
            parsed_args+=("$arg")
        fi
    done
}

parse_options() {
    local replaced=false
    local collect_unknown_args=false
    declare -g extra_args=""
    replace_aliases "${@}"
    set -- "${parsed_args[@]}"
    log_level=$log_level_info
    while [[ $# > 0 ]]; do
        arg=$1
        parse_result=0
        extra_shift=0
        shift
        case $arg in
            -h|--help|help) show_help; exit 0;;
            --debug)        set -x;;
            kube-get)       action_list+=" kube-get"; collect_unknown_args=true ;;
            kube-watch)     action_list+=" kube-watch"; collect_unknown_args=true ;;
            --*)            parse_option ${arg} "$@"; shift $extra_shift ;;
            -*)             parse_option ${arg}  "$@"; shift $extra_shift ;;
            *)
                #parse_args_logging "$@"
                if [[ "$parse_result" > 0 ]]; then
                    shift $(( "$parse_result" - 1))
                else
                    if [[ "${command_help["$arg"]:-none}" != none  ]]; then
                        command="run_command_$arg"
                    elif [[ "${action_help["$arg"]:-none}" != none  ]]; then
                        action_list+=" $arg"
                    elif [[ -f ${arg} ]]; then karmah_paths+=" ${arg}"
                    elif [[ -d ${arg} ]]; then karmah_paths+=" ${arg%%/}" # remove a trailing /
                    elif $collect_unknown_args; then extra_args+=" $arg"
                    else
                        echo unknown argument ${arg}, should be an option, action or path
                        show_short_help
                        exit 1
                    fi
                fi
        esac
    done
    verbose COMMAND $(basename $0) ${parsed_args[@]}
}
