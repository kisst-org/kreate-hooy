
init_argparse() {
    declare -gA aliases=()
    declare -ga parsed_args=()

    declare -g karmah_paths=""
    declare -g subdirs=""
    declare -ga updates=()
    declare -ga action_help=()
    declare -ga command_help=()
    declare -ga option_help=()

    declare -gA parse_arg_func=()
    declare -g action_list=""
    declare -g command
}

init_bash_module_argparse() {
    use_module logging
    add_option s subdir   dir   "add subdir to list of subdirs (can be comma separated list)"
    add_option t to       path  "other path to render to (default is tmp/manifests)"
    add_option w with     path  used for comparison between two manifest trees
    add_option u update   expr  update source files before rendering
    add_option a action   act   add action to list of actions to perform
    add_option m message  msg   set message to us with git commit
}

add_option() {
    local short=$1
    local name=$2
    local arg=$3
    shift 3
    local help=$@
    parse_arg_func[--$name]=parse_option_$name
    if [[ -z $short ]]; then
        name="--$name"
    else
        parse_arg_func[-$short]=parse_option_$name
        name="-$short|--$name"
    fi
    [[ -z $arg ]] || name+=" <$arg>"
    option_help+=("$(printf "  %-20s %s\n" "$name" "$help")")
}

parse_set_command() { command=$1; }
add_command() {
    local name=$1
    shift 1
    local help=$@
    parse_arg_func[$name]=parse_set_command
    command_help+=("$(printf "  %-13s %s\n" "$name" "$help")")
}

parse_append_action() { action_list+=$1;  }
add_action() {
    local name=$1
    shift 1
    local help="$@"
    parse_arg_func[$name]=parse_append_action
    action_help+=("$(printf "  %-13s %s\n" "$name" "$help")")
}

parse_arg() {
    local name=$1
    local func=${parse_arg_func[$name]:-}
    if [[ ! -z $func ]]; then
        parse_result=1
        $func "$@"
    fi
}


replace_aliases() {
    for arg in "${@}"; do
        local al="${aliases[$arg]:-none}"
        if [[ "$al" != none ]]; then
            replaced=true
            parsed_args+=($al)
        else
            parsed_args+=("$arg")
        fi
    done
}

parse_options() {
    local replaced=false
    local collect_unknown_args=false
    declare -g extra_args=""
    replace_aliases "${@}"
    set -- "${parsed_args[@]}"
    log_level=$log_level_info
    while [[ $# > 0 ]]; do
        arg=$1
        case $arg in
            -h|--help|help) show_help; exit 0;;
            --debug)        set -x;;
            -vv)            log_level+=10;;
            #kube-get)       action_list+=" kube-get"; collect_unknown_args=true ;;
            #kube-watch)     action_list+=" kube-watch"; collect_unknown_args=true ;;
            *)
                parse_result=0
                parse_arg "$@";
                if [[ "$parse_result" > 0 ]]; then
                    shift $(( "$parse_result" - 1))
                else
                    if [[ -f ${arg} ]]; then karmah_paths+=" ${arg}"
                    elif [[ -d ${arg} ]]; then karmah_paths+=" ${arg%%/}" # remove a trailing /
                    elif $collect_unknown_args; then extra_args+=" $arg"
                    else
                        echo unknown argument ${arg}, should be an option, action or path
                        show_short_help
                        exit 1
                    fi
                fi
        esac
        shift
    done
    verbose COMMAND $(basename $0) ${parsed_args[@]}
}
