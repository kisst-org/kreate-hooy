
init_logging() {
    declare -gi log_level_fatal=0
    declare -gi log_level_error=10
    declare -gi log_level_warn=20
    declare -gi log_level_info=30
    declare -gi log_level_verbose=40
    declare -gi log_level_debug=50
    declare -gi log_level=$log_level_info
    declare -g  log_commands=false
    parse_loglevel "$@"
}

init_bash_module_logging() {
    add_option v verbose  ""    give more output
    add_option s show-cmd ""    show the commands being executed
    add_option q quiet    ""    show no output
    add_option n dry-run  ""    do not execute the actual commands
    aliases[plan]="--quiet --dry-run --show-cmd"
}

parse_option_verbose()   { log_level+=10; }
parse_option_quiet()     { log_level=$log_level_warn; }
parse_option_show-cmd()  { log_commands=true; }
parse_option_dry-run()   { dry_run=true; }
parse_option_subdir()    { subdirs+=" $1"; extra_shift=1; }
parse_option_to()        { to_dir="$1"; extra_shift=1; }
parse_option_with()      { with_dir="$1"; extra_shift=1; }
parse_option_action()    { action_list+=" $1"; extra_shift=1; }
parse_option_message()   { git_commit_message="$1";   extra_shift=1; }
parse_option_resource()  { kube_resource_list+=" $1"; extra_shift=1; }
parse_option_replicas()  { kube_replicas="$1";  extra_shift=1; }
parse_option_version()   { update_version="$1"; extra_shift=1; }



parse_args_logging() {
    case "$1" in
        -v|--verbose)   log_level+=10;                 parse_result=1;;
        -vv)            log_level+=20;                 parse_result=1;;
        -q|--quiet)     log_level=$log_level_warn;     parse_result=1;;
        -C|--show-cmd)  log_commands=true;             parse_result=1;;
        -n|--dry-run)   dry_run=true;                  parse_result=1;;
    esac
}

log_is_error()   { (( ${log_level} >= ${log_level_error} )) }
log_is_warn()    { (( ${log_level} >= ${log_level_warn} )) }
log_is_info()    { (( ${log_level} >= ${log_level_info} )) }
log_is_verbose() { (( ${log_level:-30} >= ${log_level_verbose:-40} )) }
log_is_debug()   { (( ${log_level} >= ${log_level_debug} )) }

error()   { if $(log_is_error) ;   then printf "ERROR "; printf "%s " "${@}"; echo; fi }
warn()    { if $(log_is_warn) ;    then printf "WARN "; printf "%s " "${@}"; echo; fi }
info()    { if $(log_is_info) ;    then printf "# ";  printf "%s " "${@}"; echo; fi }
verbose() { if $(log_is_verbose) ; then printf "## "; printf "%s " "${@}"; echo; fi }
debug()   { if $(log_is_debug) ;   then printf "### ";  printf "%s " "${@}"; echo; fi }

verbose_cmd() {
    if (( $log_level >= $log_level_verbose )); then
        printf "    "; echo "${@}";
    elif $log_commands; then
        printf "    "; echo "${@}";
    fi
    if ! ${dry_run:-false}; then
        cmd=$1; shift
        $cmd "${@}"
    fi
}

verbose_pipe() {
    pipe=$1
    shift
    if (( $log_level >= $log_level_verbose )); then
        printf "    "; echo "${@}" \| $pipe;
    elif $log_commands; then
        printf "    "; echo "${@}" \| $pipe;
    fi
    if ! ${dry_run:-false}; then
        cmd=$1; shift
        $cmd "${@}" | $pipe
    fi
}


parse_loglevel() {
    for arg in "$@"; do
        parse_args_logging "${arg}" >/dev/null
    done
}
