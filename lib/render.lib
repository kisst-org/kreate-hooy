
init_bash_module_render() {
    add_action update "update source files with expressions from --update"
    add_action render "render manifests to --to <path> (default tmp/manifests)"
    add_action compare "render manifests to --to <path> (default tmp/manifests) and then compare with --with path (default deployed/manifests)"
    add_action deploy "render to deployed/manifests and optionally deploy to kubernetes"
    add_command "forall" "run actions for all paths"
    command=run_command_forall
    declare -g to_dir
    declare -g vars_to_clear="karmah_type appname env renderer output_dir"
    declare -g vars_to_declare_gA=""
}

run_action_update() {
    if [[ ${#updates[@]} == 0 ]]; then
        verbose skipping updates
        return 0
    fi
    info updating ${env} ${appname}
    for up in ${updates[@]}; do
        verbose applying update "$up"
        update_karmah_type_$karmah_type "$up"
    done
}

run_action_render() {
    run_action_update
    info rendering ${env} ${appname} to ${output_dir} with ${renderer}
    verbose_cmd rm -rf ${output_dir}
    verbose_cmd mkdir -p ${output_dir}
    for r in ${renderer//,/ }; do
        render_$r
    done
 }


render_post-render() { $post_render_func; }

run_action_compare() {
    run_action_render

    olddir=${output_dir}
    local newdir=${with_dir:-deployed/manifests}/${env}/${appname}
    info comparing ${env} ${appname}: ${output_dir} with ${newdir}

    if ${clean_before_compare:-true}; then
        verbose_cmd mkdir -p tmp/$(dirname $newdir)
        verbose_cmd cp -r $newdir tmp/$(dirname $newdir)
        newdir=tmp/${newdir}
        pre_diff_cleanup $newdir $olddir
    fi
    verbose_cmd diff -r $newdir $olddir || true
}

basic_cleanup () {
    verbose removing comments
    sed -i -e '/^ *#/d' $1/*.yaml $2/*.yaml
    verbose removing quotes around values starting or ennding with text
    sed -i -e 's/: "\([a-zA-Z].*\)"$/: \1/' $1/*.yaml $2/*.yaml
    sed -i -e 's/: "\([a-zA-Z0-9].*[a-zA-Z]\)"$/: \1/' $1/*.yaml $2/*.yaml
}

pre_diff_cleanup() {
    basic_cleanup $1 $2
}

split_into_files() {
    yq -P 'sort_keys(..)' | yq -s \"$output_dir/\"'+ (.kind | downcase) + "_" + .metadata.name + ".yaml"'
    rm -f ${output_dir}/_.yaml
}


#####################################
# run actions for all app/envs

run_command_forall() {
    for path in $karmah_paths; do
        if [[ -f $path ]]; then
            karmah_file=$path
            run_actions ${action_list:-render}
        elif [[ -z ${subdirs:-} ]]; then
            karmah_file=($path/*.karmah) # use array for globbing
            run_actions ${action_list:-render}
        else
            for sd in ${subdirs//,/ }; do
                karmah_file=($path/$sd/*.karmah)  # use array for globbing
                run_actions ${action_list:-render}
            done
        fi
    done
}

init_karmah_type_basic() {
    karmah_vars+=""
}

run_actions() {
    renderer=""
    action_list="$@"
    local karmah_type
    if [[ -f "${karmah_file}" ]]; then
        # cleanup of any vars that might have been set with previous file
        debug unsetting $vars_to_clear
        unset $vars_to_clear
        declare -gA $vars_to_declare_gA
        verbose loading ${karmah_file}
        local karmah_dir=$(dirname $karmah_file)
        local common_dir=$(dirname $karmah_dir)/common
        local used_files=${karmah_dir}
        local common_karmnah_file=($common_dir/common*.karmah)
        if [[ -f $common_karmnah_file ]]; then
            source $common_karmnah_file
        fi
        source ${karmah_file}
        init_karmah_type_${karmah_type:-basic}
        output_dir="${to_dir:-tmp/manifests}/${env}/${appname}"
        for action in ${action_list//,/ }; do
            verbose running $action with ${output_dir} for ${env} ${appname}
            run_action_$action;
        done
    else
        info skipping $karmah_file
    fi
}

run_action_deploy() {
    output_dir="${to_dir:-deployed/manifests}/${env}/${appname}"
    local actions=${deploy_actions:-render,git-diff,ask,git-commit}
    info deploying ${output_dir} with actions: ${actions}
    # TODO: output_dir is different for actions before this action
    for action in ${actions//,/ }; do
        verbose running $action with ${output_dir} for ${env} ${appname}
        run_action_$action;
    done
}
