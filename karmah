#!/usr/bin/env bash
# Script Name: render-manifests
# Description: render helm manifests for applications and environments
# Author: Mark Hooijkaas
# Sourcecode: https://github.com/kisst-org/karmah/
# License: Apache License version 2.0
# Install or update to newest version with following command:
#   curl -OL https://raw.githubusercontent.com/kisst-org/karmah/refs/heads/main/karmah && chmod 755 karmah

set -eu
shopt -s extglob
script_name="${0}"


main() {
    init_argparse
    init_logging "${@}"
    init_all_modules
    read_config
    parse_options "${@}"
    $command
}


#####################################
# argparse.lib

init_argparse() {
    declare -gA aliases=()
    declare -ga parsed_args=()

    declare -g def_paths=""
    declare -g subdirs=""
    declare -g to_dir=tmp/manifests
    declare -ga updates=()
    declare -gA command_help=()
    declare -gA action_help=()
    declare -g action_list=""
    declare -g command

    add_command aliases "show all defined aliases"
}

add_command() {
    command_help["$1"]="${2:-no help specfied}"
}
add_action() {
    action_help["$1"]="${2:-no help specfied}"
}



replace_aliases() {
    for arg in "${@}"; do
        local al="${aliases[$arg]:-none}"
        if [[ "$al" != none ]]; then
            replaced=true
            parsed_args+=($al)
        else
            parsed_args+=("$arg")
        fi
    done
}

parse_options() {
    local replaced=false
    replace_aliases "${@}"
    set -- "${parsed_args[@]}"
    log_level=$log_level_info
    while [[ $# > 0 ]]; do
        arg=$1
        case $arg in
            -h|--help|help) show_help; exit 0;;
            --debug)        set -x;;
            -s|--subdir)    subdirs+=" $2";      shift;;
            -t|--to)        to_dir="$2";         shift;;
            -w|--with)      with_dir="$2";       shift;;
            -a|--action)    action_list+="$2";   shift;;
            -u|--update)    updates+=("\"$2\""); shift;;
            *)
                parse_result=0
                parse_args_logging "$@"
                if [[ "$parse_result" > 0 ]]; then
                    shift $(( "$parse_result" - 1))
                else
                    if [[ "${command_help["$arg"]:-none}" != none  ]]; then
                        command="run_command_$arg"
                    elif [[ "${action_help["$arg"]:-none}" != none  ]]; then
                        action_list+="$arg"
                    elif [[ -f ${arg} ]]; then def_paths+=" ${arg}"
                    elif [[ -d ${arg} ]]; then def_paths+=" ${arg%%/}" # remove a trailing /
                    else
                        echo unknown argument ${arg}, should be a command, file or directory
                        show_help
                        exit 1
                    fi
                fi
        esac
        shift
    done
    verbose COMMAND $(basename $0) ${parsed_args[@]}
}

#####################################
# config.lib

read_config() {
    : ${RENDER_CONFIG_FILE:=~/.config/karmah/config}
    if [[ -f ${RENDER_CONFIG_FILE} ]]; then
        source ${RENDER_CONFIG_FILE}
    fi
    if [[ -d config.d ]] && "${use_config_d:-true}"; then
        for inc in config.d/*.config; do
            source $inc
        done
    fi
    default_renderer=${RENDER_DEFAULT_RENDERER:-helm}
}

#####################################
# copy-files.lib

render_copy-files() {
    def_file_dir=$(dirname "${def_file}")
    files_list="$def_file_dir"/${env}/files/*.yaml
    verbose_cmd cp -f ${files_list} ${output_dir}
}

apply_update_copy-files() { :; }

#####################################
# git.lib

init_module_git() {
    declare -g used_files=""
    declare -g git_pulled=false
    add_action git-diff "shows the changes to source and rendered manifests with git"
    add_action git-add "adds the changes to source and rendered manifests to git, for committing"
    add_action git-commit "commits the changes to source and rendered manifests to git"
}

run_action_ask() {
    local answer
    read -p "do you want to continue?" answer
}

run_action_git-pull() {
    verbose_cmd git pull
}

run_action_git-diff() {
    run_action_render
    info git-diff ${env} ${appname} to ${output_dir}
    if $(log_is_verbose); then
        verbose_cmd git diff -- ${used_files} ${output_dir} || true
    else
        verbose_cmd git diff -- ${used_files} ${output_dir} | grep -E '^[+-] |^---' || true
    fi
}

run_action_git-add() {
    run_action_render
    info git-add ${env} ${appname} to ${output_dir}
    verbose_cmd git add "${used_files} ${output_dir}"
}

run_action_git-status() {
    run_action_render
    git status
}


run_action_git-commit() {
    run_action_git-add
    info git commit -m "${action} of ${appname} on ${env}" "${used_files} ${output_dir}"
}

#####################################
# helm.lib

init_helm_vars() {
    local def_file_dir=$(dirname ${def_file})
    local parent_dir=$(dirname "$def_file_dir")

    helm_value_files=("helm/env-value-files/values-env-${env}.yaml")
    helm_value_files+=("$parent_dir/values*${appname}.yaml")
    helm_value_files+=("$def_file_dir/values*${appname}-${env}.yaml")

    helm_command="helm template --namespace ${namespace}" # TODO: --create-namespace does not create yaml for namespace
    appdef_vars+="helm_command helm_value_files helm_charts"
}

render_helm() {
    helm_release=$appname # this is probably not really used with helm template
    local f
    for f in ${helm_value_files[@]}; do helm_command+=" -f ${f}"; done
    helm_command+=" $helm_release"
    used_files="${helm_value_files[@]}"
    for ch in ${helm_charts//,/ }; do
        local chart=${ch//@*}
        if [[ $ch == $chart ]]; then
            used_files+=" $ch"
            verbose_pipe split_into_files "$helm_command $ch"
        else
            local repo=${ch//*@}
            verbose_pipe split_into_files "$helm_command --repo $repo $chart --version $chart_version"
        fi
    done
}

apply_update_helm() {
    local f=${helm_value_files[-1]}
    verbose applying update "$1" to "$f"
    case "$1" in
        yq:*)
            local expr="${1#yq:}"
            expr=${expr//=/=\"}\"  # add quotes around =...
            verbose_cmd yq -i "${expr}" "$f"
        ;;
        *)
            echo unknown update "$1";
            exit 1
        ;;
    esac
}

#####################################
# help.lib

show_help() {
cat <<EOF
$(basename ${script_name}) [ option | command | path ]...

Options:
  -h|--help|help      show this help and exit
  -v|--verbose        give more output
  -s|--show-cmd       show the commands being executed
  -q|--quiet          no output
  -n|--dry-run        do not execute the actual commands
  -s|--subdir <dir>   add subdir to list of subdirs (can be comma separated list)
  -t|--to <path>      other path to render to (default is tmp/manifests)
  -w|--with <path>    used for comparison between two manifest trees
  -u|--update <expr>  update source files before rendering
Commands:
EOF
for key in $(printf "%s\n" ${!command_help[@]} | sort); do
  printf "  %-13s %s\n" $key "${command_help[$key]}"
done
cat <<EOF
Paths:
  Each path defines an application definition, that will be sourced,
  This can either be a file, or a directory that contains exactly 1 file with a name '*.def'.
  When one or more --subdirs are specfied, these will be append to the path

Note:
  Options, commands and paths can be mixed freely
  If multiple commands are given, only last command will be used
EOF
}

run_command_aliases() {
echo Aliases:
for key in $(printf "%s\n" ${!aliases[@]} | sort); do
    printf "  %-13s %s\n" $key "${aliases[$key]}"
done |sort -k2 -k1
}

#####################################
# kapp.lib

init_module_kapp() {
    add_command install-kapp "install the tool kapp from carvel"
    add_action kapp-plan "show what resources will be updated"
    add_action kapp-diff "show what resources will be updated, including detailed diffs"
    add_action kapp-deploy "deploy the application with kapp"
}

run_command_install-kapp() {
    if [ -x "$(command -v kapp)" ]; then
        info kapp already installed
        #return 0
    fi
    info Installing kapp...
    local binary_type=linux-amd64
    local version=v0.64.2
    local dst_dir=~/.local/bin

    if (( $log_level >= $log_level_verbose )); then
        verbose_cmd curl    -L https://github.com/carvel-dev/kapp/releases/download/${version}/kapp-${binary_type} -o ${dst_dir}/kapp
    else
        verbose_cmd curl -s -L https://github.com/carvel-dev/kapp/releases/download/${version}/kapp-${binary_type} -o ${dst_dir}/kapp
    fi
    chmod +x ${dst_dir}/kapp
    verbose Installed ${dst_dir}/kapp ${version}
}

kapp_options() {
    local cl=$(kube_cluster)
    local cfg=${kubeconfig[$cl]:-default}
    local opt=""
    if [[ $cfg != default ]]; then
        opt="--kubeconfig $cfg " # extra space at end
    fi
    opt+="--kubeconfig-context ${kubecontext[$cl]} -n ${namespace} -a ${appname} -f ${output_dir}"
    echo $opt
}

run_action_kapp-diff() {
    run_action_render
    verbose_cmd kapp deploy $(kapp_options) --diff-run --diff-changes
}

run_action_kapp-plan() {
    run_action_render
    verbose_cmd kapp deploy $(kapp_options) --diff-run
}

run_action_kapp-deploy() {
    run_action_render
    if ! kubectl $(kubectl_options) get ns $namespace >/dev/null 2>&1; then
        verbose_cmd kubectl $(kubectl_options) create ns $namespace
    fi
    verbose_cmd kapp deploy $(kapp_options)
}

#####################################
# kube.lib

init_module_kube() {
    declare -Ag cluster
    declare -Ag kubeconfig
    declare -Ag kubecontext
    add_action kube-get "get current manifests from cluster to --to <path> (default) deployed/manifests"
    add_action kube-apply "apply rendered manifests with cluster (kubectl apply)"
    add_action kube-diff "compare rendered manifests with cluster (kubectl diff)"
}

kube_cluster() {
    local cl=${cluster[$env,$appname]:-${cluster[$env]:-undefined}}
    if [[ $cl == undefined ]]; then
        error unknown cluster for $env
        exit 1
    fi
    echo $cl
}

kubectl_options() {
    local cl=$(kube_cluster)
    local cfg=${kubeconfig[$cl]:-default}
    local opt=""
    if [[ $cfg != default ]]; then
        opt="--kubeconfig $cfg " # extra space at end
    fi
    opt+="--context ${kubecontext[$cl]}"
    echo $opt
}

filter-kube-diff-output() { grep -E '^[+-] |^---'; }
run_action_kube-diff() {
    run_action_render
    info kube-diff ${env} ${appname} to ${output_dir}
    if $(log_is_verbose); then
        verbose_cmd kubectl diff $(kubectl_options) -f $output_dir || true
    else
        verbose_pipe filter-kube-diff-output kubectl diff $(kubectl_options) -f $output_dir || true
    fi
}

run_action_kube-apply() {
    run_action_kube-diff
    info kube apply $output_dir
    verbose_cmd kubectl apply $(kubectl_options) -f $output_dir
}

split_kubectl_output_into_files() {
    yq  '.items.[]' -s \"$output_dir/\"'+ (.kind | downcase) + "_" + .metadata.name + ".yaml"'
}

run_action_kube-get-manifests() {
    info kube get manifests  ${env} ${appname} to ${output_dir}
    verbose_cmd rm -rf ${output_dir}
    verbose_cmd mkdir -p ${output_dir}
    verbose_pipe split_kubectl_output_into_files kubectl ${kubectl_options[$env]} -n "${namespace}" get deploy,svc,sts,cm,ingress -o yaml
    ignore_files=configmap_kube-root-ca.crt.yaml
    ignore_files+=" deployment_ingress-nginx-controller.yaml"
    ignore_files+=" service_ingress-nginx-controller-admission.yaml"
    ignore_files+=" service_ingress-nginx-controller.yaml"
    for f in ${ignore_files}; do
        rm -f "${output_dir}/$f"
    done
    for f in "${output_dir}"/*.yaml; do
         yq -i 'del(.metadata.annotations.["kubectl.kubernetes.io/last-applied-configuration"])' "${f}"
         yq -i 'del(.metadata.uid)' "${f}"
         yq -i 'del(.metadata.resourceVersion)' "${f}"
         yq -i 'del(.metadata.creationTimestamp)' "${f}"
    done
}

#####################################
# kustomize.lib

render_kustomize() {
    local command="kubectl kustomize --enable-helm"
    #used_files+=" $helm_chart_dir/$ch"
    verbose_pipe split_into_files "$command $(dirname ${def_file})"
}

#####################################
# logging.lib

init_logging() {
    declare -gi log_level_fatal=0
    declare -gi log_level_error=10
    declare -gi log_level_warn=20
    declare -gi log_level_info=30
    declare -gi log_level_verbose=40
    declare -gi log_level_debug=50
    declare -gi log_level=$log_level_info
    declare -g  log_commands=false
    parse_loglevel "$@"
}

parse_args_logging() {
    case "$1" in
        -v|--verbose)   log_level+=10;                 parse_result=1;;
        -vv)            log_level+=20;                 parse_result=1;;
        -q|--quiet)     log_level=$log_level_warn;     parse_result=1;;
        -C|--show-cmd)  log_commands=true;             parse_result=1;;
        -n|--dry-run)   dry_run=true;                  parse_result=1;;
    esac
}

log_is_error()   { (( ${log_level} >= ${log_level_error} )) }
log_is_warning() { (( ${log_level} >= ${log_level_warning} )) }
log_is_info()    { (( ${log_level} >= ${log_level_info} )) }
log_is_verbose() { (( ${log_level:-30} >= ${log_level_verbose:-40} )) }
log_is_debug()   { (( ${log_level} >= ${log_level_debug} )) }

error()   { if $(log_is_error) ;   then printf "ERROR "; printf "%s " "${@}"; echo; fi }
warning() { if $(log_is_warning) ; then printf "WARN "; printf "%s " "${@}"; echo; fi }
info()    { if $(log_is_info) ;    then printf "# ";  printf "%s " "${@}"; echo; fi }
verbose() { if $(log_is_verbose) ; then printf "## "; printf "%s " "${@}"; echo; fi }
debug()   { if $(log_is_debug) ;   then printf "### ";  printf "%s " "${@}"; echo; fi }

verbose_cmd() {
    if (( $log_level >= $log_level_verbose )); then
        printf "    "; echo "${@}";
    elif $log_commands; then
        printf "    "; echo "${@}";
    fi
    if ! ${dry_run:-false}; then
        cmd=$1; shift
        $cmd "${@}"
    fi
}

verbose_pipe() {
    pipe=$1
    shift
    if (( $log_level >= $log_level_verbose )); then
        printf "    "; echo "${@}" \| $pipe;
    elif $log_commands; then
        printf "    "; echo "${@}" \| $pipe;
    fi
    if ! ${dry_run:-false}; then
        cmd=$1; shift
        $cmd "${@}" | $pipe
    fi
}


parse_loglevel() {
    for arg in "$@"; do
        parse_args_logging "${arg}" >/dev/null
    done
}

#####################################
# module.lib

load_module() {
    file="$1"
    shift
    if [[ ${module_files["${file}"]:-} == loaded ]]; then
        verbose skipping module file "${file}" already loaded
        return 0
    fi
    module_files["${file}"]=loaded
    local filename="$(basename "${file}")"
    local module="${filename%%.lib}"
    verbose loading module "${module}" from "${file}"
    source "${file}"
}

use_module() {
    local module="$1"
    if ${module_needs_init["${module}"]:-true}; then
        verbose running init module for "${module}"
        init_module_${module}
        module_needs_init["${module}"]=false
    fi
}

init_all_modules() {
    declare -g modules=""
    declare -gA module_needs_init=()
    declare -gA module_files=()
    modules=$(set | grep '^init_module_'| sed -e 's/init_module_//' -e 's/ *()//')
    for m in $modules; do
        use_module $m
    done
}

#####################################
# render.lib

init_module_render() {
    add_action update "update source files with expressions from --update"
    add_action render "render manifests to --to <path> (default tmp/manifests)"
    add_action compare "render manifests to --to <path> (default tmp/manifests) and then compare with --with path (default deployed/manifests)"
    add_command "forall" "run actions for all paths"
    command=run_command_forall
}

run_action_update() {
    if [[ ${#updates[@]} == 0 ]]; then
        verbose skipping updates
        return 0
    fi
    info updating ${env} ${appname}
    for up in ${updates[@]}; do
        verbose applying update "$up"
        apply_update_$renderer "$up"
    done
}

run_action_render() {
    run_action_update
    info rendering ${env} ${appname} to ${output_dir} with ${renderer}
    verbose_cmd rm -rf ${output_dir}
    verbose_cmd mkdir -p ${output_dir}
    for r in ${renderer//,/ }; do
        render_$r
    done
 }


render_post-render() { $post_render_func; }

run_action_compare() {
    run_action_render

    olddir=${output_dir}
    local newdir=${with_dir:-deployed/manifests}/${env}/${appname}
    info comparing ${env} ${appname}: ${output_dir} with ${newdir}

    if ${clean_before_compare:-true}; then
        verbose_cmd mkdir -p tmp/$(dirname $newdir)
        verbose_cmd cp -r $newdir tmp/$(dirname $newdir)
        newdir=tmp/${newdir}
        pre_diff_cleanup $newdir $olddir
    fi
    verbose_cmd diff -r $newdir $olddir || true
}

basic_cleanup () {
    verbose removing comments
    sed -i -e '/^ *#/d' $1/*.yaml $2/*.yaml
    verbose removing quotes around values starting or ennding with text
    sed -i -e 's/: "\([a-zA-Z].*\)"$/: \1/' $1/*.yaml $2/*.yaml
    sed -i -e 's/: "\([a-zA-Z0-9].*[a-zA-Z]\)"$/: \1/' $1/*.yaml $2/*.yaml
}

pre_diff_cleanup() {
    basic_cleanup $1 $2
}

split_into_files() {
    yq -P 'sort_keys(..)' | yq -s \"$output_dir/\"'+ (.kind | downcase) + "_" + .metadata.name + ".yaml"'
    rm -f ${output_dir}/_.yaml
}


#####################################
# run actions for all app/envs

run_command_forall() {
    for path in $def_paths; do
        if [[ -f $path ]]; then
            def_file=$path
            run_actions ${action_list:-render}
        elif [[ -z ${subdirs:-} ]]; then
            def_file=($path/*.def) # use array for globbing
            run_actions ${action_list:-render}
        else
            for sd in ${subdirs//,/ }; do
                def_file=($path/$sd/*.def)  # use array for globbing
                run_actions ${action_list:-render}
            done
        fi
    done
}

init_appdef_basic() {
    appdef_vars+=""
}

run_actions() {
    renderer=""
    action_list="$@"
    local appdef_type
    local appdef_vars="appdef_type appdef_vars appname env"
    if [[ -f "${def_file}" ]]; then
        verbose loading ${def_file}
        source ${def_file}
        init_appdef_${appdef_type:-basic}
        output_dir="${to_dir}/${env}/${appname}"
        for action in ${action_list//,/ }; do
            verbose running $action with ${output_dir} for ${env} ${appname}
            run_action_$action;
        done
        # cleanup of any vars set in init_appdef_...
        verbose unsetting $appdef_vars
        unset $appdef_vars
    else
        info skipping $def_file
    fi
}

#####################################
main "${@}"
