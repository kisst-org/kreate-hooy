#!/usr/bin/env bash
# Script Name: render-manifests
# Description: render helm manifests for applications and environments
# Author: Mark Hooijkaas
# Sourcecode: https://github.com/kisst-org/kreate-hooy/
# License: Apache License version 2.0
# Install or update to newest version with following command:
#   curl -OL https://raw.githubusercontent.com/kisst-org/kreate-hooy/refs/heads/main/kreate && chmod 755 kreate

set -eu
shopt -s extglob
script_name="${0}"


main() {
    init_logging "${@}"
    init_all_modules
    read_config
    parse_options "${@}"
    $command
}

#####################################
# action-list module


init_module_action-list() {
    declare -g action_list=update,render
    declare -gA enabled=()
}

################################################
# run actions

forall-appenvs() {
    for def_file in $def_files; do
        for env in $envs; do
            run_actions "$@"
        done
    done
}
forall-envapps() {
    for env in $envs; do
        for f in $def_files; do
            run_actions "$@"
        done
    done
}

run_actions() {
    renderer=""
    skip=false
    action_list="$@"
    source ${def_file}
    init_renderer_${renderer}
    output_dir="${to_dir}/${env}/${appname}"
    if ${skip}; then
        info skipping $appname $env
        return 0
    fi
    for action in ${action_list//,/ }; do
        if "${enabled[$action]:-true}"; then
            verbose running $action with ${output_dir} for ${env} ${appname}
            run_action_$action;
        fi
    done
}
#####################################
# actions module

init_module_actions() {
    use_module argparse
    add_command update "update source files with expressions from --update"
    add_command render "render manifests to --to <path> (default tmp/manifests)"
    add_command compare "render manifests to --to <path> (default tmp/manifests) and then compare with --with path (default deployed/manifests)"
}

run_command_update() { forall-appenvs update; }
run_command_render() { forall-appenvs update,render;}
run_command_compare() { forall-appenvs update,render,compare;}

run_action_update() {
    if [[ ${#updates[@]} == 0 ]]; then
        verbose skipping updates
    fi
    for up in ${updates[@]}; do
        verbose applying update "$up"
        apply_update_$renderer "$up"
    done
}

run_action_render() {
    info rendering  ${env} ${appname} to ${output_dir}
    $render_func
 }


run_action_compare() {
    olddir=${output_dir}
    local newdir=${with_dir:-deployed/manifests}/${env}/${appname}
    info comparing ${env} ${appname}: ${output_dir} with ${newdir}

    if ${clean_before_compare:-true}; then
        verbose_cmd mkdir -p tmp/$(dirname $newdir)
        verbose_cmd cp -r $newdir tmp/$(dirname $newdir)
        newdir=tmp/${newdir}
        pre_diff_cleanup $newdir $olddir
    fi
    verbose_cmd diff -r $newdir $olddir || true
}

basic_cleanup () {
    verbose removing comments
    sed -i -e '/^ *#/d' $1/*.yaml $2/*.yaml
    verbose removing quotes around values starting or ennding with text
    sed -i -e 's/: "\([a-zA-Z].*\)"$/: \1/' $1/*.yaml $2/*.yaml
    sed -i -e 's/: "\([a-zA-Z0-9].*[a-zA-Z]\)"$/: \1/' $1/*.yaml $2/*.yaml
}

pre_diff_cleanup() {
    basic_cleanup $1 $2
}

split_into_files() {
    yq -s \"$output_dir/\"'+ (.kind | downcase) + "_" + .metadata.name + ".yaml"'
    rm -f ${output_dir}/_.yaml
}
#####################################
# argparse module

init_module_argparse() {
    declare -gA aliases=()
    declare -ga parsed_args=()

    declare -g def_files=""
    declare -g envs=""
    declare -g to_dir=tmp/manifests
    declare -ga updates=()
    declare -gA command_help=()
    declare -g command=run_command_render

    add_command aliases "show all defined aliases"
}

add_command() {
    command_help["$1"]="${2:-no help sepcfied}"
}

replace_aliases() {
    for arg in "${@}"; do
        local al="${aliases[$arg]:-none}"
        if [[ "$al" != none ]]; then
            replaced=true
            parsed_args+=($al)
        else
            parsed_args+=("$arg")
        fi
    done
}

parse_options() {
    local replaced=false
    replace_aliases "${@}"
    set -- "${parsed_args[@]}"
    log_level=$log_level_info
    while [[ $# > 0 ]]; do
        arg=$1
        case $arg in
            -h|--help|help) show_help; exit 0;;
            --debug)        set -x;;
            -e|--env)       envs+=" $2";        shift;;
            -r|--run)       action_list="$2";   shift;;
            --to)           to_dir="$2";    shift;;
            --with)         with_dir="$2";      shift;;
            --update)       updates+=("\"$2\"");shift;;
            *)
                parse_result=0
                parse_args_logging "$@"
                if [[ "$parse_result" > 0 ]]; then
                    shift $(( "$parse_result" - 1))
                else
                    if [[ "${command_help["$arg"]:-none}" != none  ]]; then
                        command="run_command_$arg"
                    elif [[ -f ${arg} ]]; then def_files+=" ${arg}"
                    elif [[ -d ${arg} ]]; then def_files+=" ${arg}/*.def"
                    else
                        echo unknown argument ${arg}, should be a command, file or directory with one \*.def file
                        show_help
                        exit 1
                    fi
                fi
        esac
        shift
    done
    verbose COMMAND $(basename $0) ${parsed_args[@]}
    if [[ -z $envs ]]; then envs=${RENDER_DEFAULT_ENVS:-tst}; fi
    envs=${envs//,/ }  # split on comma
    # better test that also works with one or more spaces, might be:
    #   if [[ ${envs:-} =~ '^ *$' ]]; then ...
    # see https://unix.stackexchange.com/questions/146942/how-can-i-test-if-a-variable-is-empty-or-contains-only-spaces
}
#####################################
# config module

read_config() {
    : ${RENDER_CONFIG_FILE:=~/.config/kreate-hooy/config}
    if [[ -f ${RENDER_CONFIG_FILE} ]]; then
        source ${RENDER_CONFIG_FILE}
    fi
    if [[ -d config.d ]] && "${use_config_d:-true}"; then
        for inc in config.d/*.config; do
            source $inc
        done
    fi
    default_renderer=${RENDER_DEFAULT_RENDERER:-helm}
}
#####################################
# helm module


init_renderer_copy-files() {
    def_file_dir=$(dirname "${def_file}")
    files_list="$def_file_dir"/files/${env}/*.yaml
    if [[ -z ${files_list} ]]; then
        skip=true
        return 0
    fi
    render_func=render_copy-files
}

render_copy-files() {
    verbose_cmd rm -rf ${output_dir}
    verbose_cmd cp -f ${files_list} ${output_dir}
}

apply_update_copy-files() { :; }
#####################################
# git module


init_module_git() {
    use_module argparse
    declare -g used_files=""
    aliases[deploy]="run:git-pull,update,render,kube-diff,git-diff,ask,git-add,git-commit to:deployed/manifests"
    declare -g git_pulled=false
    add_command git-diff "shows the changes to source and rendered manifests with git"
    add_command git-add "adds the changes to source and rendered manifests to git, for committing"
    add_command git-commit "commits the changes to source and rendered manifests to git"
}

run_command_git-diff() { forall-appenvs update,render,git-diff; }
run_command_git-add() { forall-appenvs update,render,git-add; }
run_command_git-commit() { forall-appenvs update,render,git-add,git-commit; }

run_action_ask() {
    local answer
    read -p "do you want to continue?" answer
}

run_action_git-pull() {
    verbose_cmd git pull
}

run_action_git-diff() {
    if $(log_is_verbose); then
        verbose_cmd git diff -- ${used_files} ${output_dir} || true
    else
        verbose_cmd git diff -- ${used_files} ${output_dir} | grep -E '^[+-] |^---' || true
    fi
}

run_action_git-add() {
    verbose_cmd git add "${used_files} ${output_dir}"
}

run_action_git-status() {
    git status
}


run_action_git-commit() {
    info git commit -m "${action} of ${appname} on ${env}" "${used_files} ${output_dir}"
}
#####################################
# helm module


init_renderer_helm() {
    helm_chart_dir=helm/charts
    def_file_dir=$(dirname ${def_file})
    main_env_file="$def_file_dir/values-${appname}-${env}.yaml"
    if [[ ! -f $main_env_file ]]; then
        skip=true
        return 0
    fi
    helm_value_files=(helm/env-value-files/values-env-${env}.yaml)
    helm_value_files+=("$def_file_dir/values-app-${appname}.yaml")
    helm_value_files+=("$main_env_file")
    #run_update_func=update_last_helm_values_file
    render_func=render_helm
    helm_command="helm template"
}

render_helm() {
    helm_release=$appname # this is probably not really used with helm template
    local f
    for f in ${helm_value_files[@]}; do helm_command+=" -f ${f}"; done
    helm_command+=" $helm_release"
    used_files="${helm_value_files[@]}"
    verbose_cmd rm -rf ${output_dir}
    for ch in $helm_charts; do
        used_files+=" $helm_chart_dir/$ch"
        local cmd="$helm_command $helm_chart_dir/$ch"
        verbose "    $cmd"
        $cmd | split_into_files
    done
}

apply_update_helm() {
    local f=${helm_value_files[-1]}
    verbose applying update "$1" to "$f"
    case "$1" in
        yq:*)
            local expr="${1#yq:}"
            expr=${expr//=/=\"}\"  # add quotes around =...
            verbose_cmd yq -i "${expr}" "$f"
        ;;
        *)       echo unknown update "$1"; exit 1;;
    esac
}
#####################################
# help module

show_help() { cat <<EOF
$(basename ${script_name}) [ option | render-def ]...

Options:
  -h|--help     show this help
  -v|--verbose  give more output
  -s|--show-cmd show the commands being executed
  -q|--quiet    no output
  -e|--env <e>  add environment <e> to render (can be comma separated list)
  --run <act>   run a list of actions for each app/env combination
  --to <path>   other path to render to (default is tmp/manifests)
Commands
  help          show this _help
  aliases       show all defines aliases
  diff          run 'kubectl diff' with the rendered manifests
  apply         run 'kubectl apply' with the rendered manifests
  compare:<to>  compare to same in other manifests directory
  update <expr> update some expression
  update:<expr> <value> update some expression with some value
  commit        TODO: run 'git commit' (pull is implied)
  pull          TODO: run 'git pull' before starting to render, to avoid merge conflicts
  cmd:<cmd>     run a user defined command

Render Definitions:
Can either be a file, that will be sourced, or a directory that contains exactly 1 file with a name 'render*.def'.

Note: options end render-definitions can be freely mixed
EOF
}

run_command_aliases() {
echo Aliases:
for key in $(printf "%s\n" ${!aliases[@]} | sort); do
    printf "  %-13s %s\n" $key "${aliases[$key]}"
done |sort -k2 -k1
}
#####################################
# kube module

init_module_kube() {
    use_module argparse
    declare -Ag kubectl_options
    add_command kube-get "get current manifests from cluster to --to <path> (default) deployed/manifests"
    add_command kube-apply "apply rendered manifests with cluster (kubectl apply)"
    add_command kube-diff "compare rendered manifests with cluster (kubectl diff)"
}

run_command_kube-get() { forall-appenvs kube-get-manifests; }
run_command_kube-diff() { forall-appenvs update,render,kube-diff; }
run_command_kube-apply() { forall-appenvs update,render,kube-diff,kube-apply; }


run_action_kube-diff() {
    if $(log_is_verbose); then
        verbose_cmd kubectl diff ${kubectl_options[$env]} -f $output_dir || true
    else
        verbose_cmd kubectl diff ${kubectl_options[$env]} -f $output_dir | grep -E '^[+-] |^---' || true
    fi
}

run_action_kube-apply() {
    info applying $output_dir
    verbose_cmd kubectl apply ${kubectl_options[$env]} -f $output_dir
}

split_kubectl_output_into_files() {
    yq  '.items.[]' -s \"$output_dir/\"'+ (.kind | downcase) + "_" + .metadata.name + ".yaml"'
}

run_action_kube-get-manifests() {
    verbose_cmd rm -rf ${output_dir}
    verbose_cmd mkdir -p ${output_dir}
    local cmd="kubectl ${kubectl_options[$env]} -n "${namespace}" get deploy,svc,sts,cm,ingress -o yaml"
    verbose "    $cmd"
    $cmd | split_kubectl_output_into_files
    ignore_files=configmap_kube-root-ca.crt.yaml
    ignore_files+=" deployment_ingress-nginx-controller.yaml"
    ignore_files+=" service_ingress-nginx-controller-admission.yaml"
    ignore_files+=" service_ingress-nginx-controller.yaml"
    for f in ${ignore_files}; do
        rm -f "${output_dir}/$f"
    done
    for f in "${output_dir}"/*.yaml; do
         yq -i 'del(.metadata.annotations.["kubectl.kubernetes.io/last-applied-configuration"])' "${f}"
         yq -i 'del(.metadata.uid)' "${f}"
         yq -i 'del(.metadata.resourceVersion)' "${f}"
         yq -i 'del(.metadata.creationTimestamp)' "${f}"
    done
}
#####################################
# logging module

init_logging() {
    declare -gi log_level_fatal=0
    declare -gi log_level_error=10
    declare -gi log_level_warn=20
    declare -gi log_level_info=30
    declare -gi log_level_verbose=40
    declare -gi log_level_debug=50
    declare -gi log_level=$log_level_info
    declare -g  log_commands=false
    parse_loglevel "$@"
}

parse_args_logging() {
    case "$1" in
        -v|--verbose)   log_level=$log_level_verbose;  parse_result=1;;
        -q|--quiet)     log_level=$log_level_warn;     parse_result=1;;
        -s|--show-cmd)  log_commands=true;             parse_result=1;;
    esac
}

log_is_verbose() { (( ${log_level:-30} >= ${log_level_verbose:-40} )) }
log_is_info()    { (( $log_level >= $log_level_info )) }

verbose() { if $(log_is_verbose) ; then printf "## "; printf "%s " "${@}"; echo; fi }
info() {    if $(log_is_info) ;    then printf "# ";  printf "%s " "${@}"; echo; fi }
#info()    { if ${log_info:-true};     then echo "${@}"; fi }
verbose_cmd() {
    if (( $log_level >= $log_level_verbose )); then
        printf "    "; echo "${@}";
    elif $log_commands; then
        printf "    "; echo "${@}";
    fi
    cmd=$1; shift
    $cmd "${@}"
}


parse_loglevel() {
    for arg in "$@"; do
        parse_args_logging "${arg}" >/dev/null
    done
}
#####################################
# module functions

load_module() {
    file="$1"
    shift
    if [[ ${module_files["${file}"]:-} == loaded ]]; then
        verbose skipping module file "${file}" already loaded
        return 0
    fi
    module_files["${file}"]=loaded
    local filename="$(basename "${file}")"
    local module="${filename%%.lib}"
    verbose loading module "${module}" from "${file}"
    source "${file}"
}

use_module() {
    local module="$1"
    if ${module_needs_init["${module}"]:-true}; then
        verbose running init module for "${module}"
        init_module_${module}
        module_needs_init["${module}"]=false
    fi
}

init_all_modules() {
    declare -g modules=""
    declare -gA module_needs_init=()
    declare -gA module_files=()
    modules=$(set | grep '^init_module_'| sed -e 's/init_module_//' -e 's/ *()//')
    for m in $modules; do
        use_module $m
    done
}

##################
main "${@}"
